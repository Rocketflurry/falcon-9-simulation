------------------------------------------------CURRENTLY WORKING ON------------------------------------------------
...integrating the second stage into the application.

This involves two sections.

1. Internally integrating the second stage involves code in 'ILaunchVehicle' and 'Falcon9' to allow the launch vehicle
   to use the forces and torques produced by its child stages and set their positions/orientations in world space.
   This stage-to-LV relationship should be carefully monitored and reviewed - it is quite significant. The stages
   should be able to separate of course, and behave entirely independently from the LV.

2. Once the task above is done and the second stage is nicely integrated into the internal side of the application,
   it must be rendered. This problem prompts questions such as 'should there be a ILaunchVehicleModel class?' and
   'is there any way to abstract away the shared code between F9S1Model and F9S2Model - an IStageModel perhaps?'.
   Currently - to debug the internal side of things - the SimulationModelLayer simply contains two objects
   'F9S1Model' and 'F9S2Model' that are both attached to a 'Falcon9Stage1' and 'Falcon9Stage2' respectively, that
   are passed in (through the 'Falcon9' object). Much of the code in 'F9S1Model' and 'F9S2Model' is duplicated.
   It *might* be the best option to have two objects here, one for each stage...

   |
   
   OR... there could be one monolithic 'Falcon9Model' class that contains everything to do with the Falcon9 (both
   stages all in one). This could be initialised once with the 'Falcon9' instance, and just left to work. It would
   be in charge of rendering all stages and components. This might be too hard to contain in one class, as it could
   quickly become unmaintainable.

   |

   OR... meet halfway and have an 'F9S1Model' and an 'F9S2Model' contained within a 'Falcon9Model' class. Both
   stage models could be hidden behind this class, and - on taking in a 'Falcon9' - it could initialise them
   both.

Once this has been done, consider checking that the numbers (masses, dimensions, positions etc) within the second 
stage are correct. LV is currently 10 tonnes over true value (this could be from S1 of course, but check it all).

  -------------------------------------------------------------------------------------------------------------------
* Redo the UILayer. Decide on a concrete design/system and stick to it.

-------------------------------------------------------------------------------------------------------------------
* Add an updated option to the TVC actuator system. 

  - The system is currently highly dependent on unknown information. The positions of the ends of the actuators on 
    the base of the stage and the engine are completely unknown, and as a result the length/range of the actuator 
	is unknown. At the moment, actuators are given extension percentages. These then set the actuators to a specific 
	length, which in turn changes the engine's angle. This works, but it is based on unknown info. Since within
	control code the lengths and positions of the actuator will just be re-abstracted away behind simplified angle
	variables, an alternative option might be nicer.

  - Why not just go straight for an angle-based implementation. We'd call Engine.setGimbal(90.0, 5.0) or something 
    similar, to say that the engine is gimballed 5 degs radially along an axis rotated 90 degs around some central axis
	of rotation, from some 'starting' axis. The actuator objects would then become reactive and assume their correct
	positions given the engine's new state.

  - It should still be possible to use the old method, but this new one is likely to be more common. All the old
    angle constraints can still be used with this method. Overall just re-consider the whole approach with actuators
	with control code in mind.

-------------------------------------------------------------------------------------------------------------------
* Try to add a similar debug view for the first stage as the vehicle physics simulation with vectors. This will involve
  making a BasicModel and DebugModel and rendering the debug view over the top of the BasicModel. The DebugModel could
  include overlayed propellant tank visualisations and centre of mass markers (suggestions).

-------------------------------------------------------------------------------------------------------------------
- The force from the engines is generating a miniscule amount of rotation of the stage for some reason, even though
  it should all be applied perfectly vertically. The error can be eliminated by removing the torque generated by
  the engines. This does not *confirm* that they are the cause, but it is likely.

  To reproduce:
  1. Expand the resolution of the debug data to 10 decimal places, to have a chance at detecting the error at all
  2. Speed up the simulation to 10x normal speed
  3. Fly the stage vertically upwards and watch the angular momentum.

  The angular momentum of the stage will start to change after a few seconds. Other values will follow this (as a
  result of the stage rotating a small amount, the velocity and position change etc.).

  Work out what it is that is causing this rotation. Check that all centres of mass are perfectly central and
  that the force generated by the engines is also perfectly vertical.

-----------
WHAT'S CURRENTLY KNOWN
-----------
  This issue is caused by a torque being incorrectly generated. The torque is only generated (obviously) when the
  engines are active, as they are the only force required to reproduce the bug.

  1. Firstly, the centre of mass of the stage is not completely accurate. This inaccuracy is caused by the GridFins
     and the LandingLegs i.e. all StageComponentGroups (containing IStageComponents). There must be some problem
	 with the rotation and positioning of StageComponents, which results in a slightly inaccurate centre of mass for
	 each of them. This is then combined in the group, and eventually combined with the total centre of mass of
	 the stage. If the x and z components of the stage's centre of mass are set to 0.0, then (when the issue below
	 is ALSO fixed) the error disappears, showing that it is caused in some part by an inaccurate centre of mass.

  2. In addition to the issue above, the *positioning* of 8 out of 9 engines (the surrounding engines) also adds
     to the error. If the engines are all positioned in the centre of the stage (when the issue above is ALSO fixed)
	 the error disappears, showing that is is caused in some part by inaccurate positioning of the outer engines.
-------------------------------------------------------------------------------------------------------------------







* Look into the RK-4 integrator. AFAIK, it is currently not correct. GafferOnGames says that the getForce() and
  getTorque() functions *must* be able to calculate all forces from within this function, only given the previous
  state. Surely this means that the state of the rocket must be woven into the RigidBody state - this might involve
  adding a custom area for states added to the default properties that a State contains. This way, all properties
  can be updated from within the integrator - perhaps add a 'perStepUpdate()' function to do this. Anyway, check it.










- Add the forces and torques produced by the grid fins (GridFins.cpp)

- 3 areas to work on currently
  - Give the grid fins some sort of force (and torque)
  - Recalculate the lift coefficient of the stage at any point (done within the aerodynamic model)
  - Calculate the centre of pressure of the stage at any point

- Implement collision detection.

- Update the wind velocity randomly. Implement realistic wind at different altitudes.

------------------------------------------------------- 
Before any work is done to combine the two stage objects into one 'LaunchVehicle' object, complete all aspects of both
stages. Completely finish *EVERYTHING* on both stages before moving on.

	- Get proper rocket equations in use (mass flow rate, thrust etc)
      https://www.grc.nasa.gov/www/K-12/airplane/rktthsum.html
	
	- Add complete collision detection for each stage while moving independently.
-------------------------------------------------------

- Try to account for rotational drag of stages

- Introduce chaos/uncertainty/error around the simulation and in the environment. Fluctuations of values. This will give the
  control module something more to work against. This needs to be toggleable (perhaps using preprocessors).

- Make sure that mMiscInertMass is correct, once all specific components have been added to stages.

- Create payload class.

- Create a Falcon9 object that contains the two stages (and a payload).

- Consider trying to create some sort of 'failure prediction' system that assess the current state of the rocket based on
  lots of different factors and decides whether it is beyond the point of saving. Only add this though, once the control module
  has been successfully implemented. This could increase the speed at which different control systems can be created. If the 
  program knows that the rocket cannot be saved, then there is no point continuing the simulation. The program could warn the user
  that a failure has been predicted and ask if they would like to continue or not. This should speed up creation of control algorithms.

- Add units in comments to all member variables present in the code, similar to what has been done with environment.

- Worth checking the geopotential/geometric conversions in the Environment class now that the Earth is being modelled as an ellipsoid.

- (Very, very long term...) 
  The reference area in AerodynamicModel::updateReferenceArea() could be calculated eventually by rendering 
  the view of an orthographic 'wind' camera, to a low, fixed resolution, pure black and white texture. The  
  front vector of the wind camera would be the wind velocity, so it would look at the object in the 
  direction of the wind.
  Some basic image analysis - simply going through counting white pixels - would determine a total
  number of pixels used by the object. Keeping the camera at a constant distance from the object
  would mean that each pixel represented a constant area. Total * area = totalArea. This could then be
  passed to the function for the reference area to be updated.