#include "CameraSystem.h"
#include "../../input/HWEventReceiver.h"

#include <chrono_irrlicht/ChIrrTools.h>


bool CameraSystem::mInitialised = false;
float CameraSystem::mAspectRatio = 1.0f;
irr::scene::ICameraSceneNode* CameraSystem::mIrrlichtCam = nullptr;
std::vector<CameraSystem::CameraHandle> CameraSystem::mCameraHandles;
CameraSystem::CameraHandle CameraSystem::mActiveCamera;


void CameraSystem::init(irr::scene::ISceneManager& sceneMgrHandle) {
    mIrrlichtCam = sceneMgrHandle.addCameraSceneNode();
    mIrrlichtCam->setPosition({0, 0, 0});
    sceneMgrHandle.setActiveCamera(mIrrlichtCam);
    mInitialised = true;
}


void CameraSystem::handleInput() {
    // todo: cycling through the cameras when 'C' is pressed.
}


void CameraSystem::setScreenAspectRatio(float aspectRatio) {
    mAspectRatio = aspectRatio;
}


void CameraSystem::updateIrrlichtCamera() {
    // Updates the state of the internal irrlicht camera based on the currently bound `CameraBaseState`.
    const CameraBaseState* current = mActiveCamera.handle;

    mIrrlichtCam->setUpVector(irr::core::vector3dfCH(current->up));
    mIrrlichtCam->setTarget(irr::core::vector3dfCH(current->lookAt));
    mIrrlichtCam->setNearValue(current->nearValue);
    mIrrlichtCam->setFarValue(current->farValue);
    mIrrlichtCam->setFOV(irr::core::degToRad(current->verticalFOV));

    // Currently, there is only one camera view shown on screen at a time, and the image generated by this camera always
    // fills the screen. Hence it makes sense that this class should hold one variable for a 'main' aspect ratio, and
    // all camera views should use this variable. The currently bound camera's 'aspectRatio' variable is ignored.
    //
    // However in the future, the plan is to add multiple camera views with different aspect ratios, at which point
    // `current->aspectRatio` should be used here.
    mIrrlichtCam->setAspectRatio(mAspectRatio);
}


void CameraSystem::registerHandleTo(CameraBaseState& cameraState, const std::string& name) {
    mCameraHandles.push_back({name, &cameraState});
    mActiveCamera = mCameraHandles.back();
}


chrono::ChVector<> CameraSystem::getActiveCameraPos() {
    return mActiveCamera.handle->position;
}
