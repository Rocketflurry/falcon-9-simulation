#include "LandingLeg.h"	 

namespace Physics {
	namespace Hardware {

		LandingLeg::LandingLeg(double clockingDegree) :
			IStageComponent(CoordTransform3D(), recalcMass(), recalcInertia()),
			mClockingDegree(clockingDegree),
			mClockingRotation_stage(glm::rotate(glm::radians(clockingDegree), glm::dvec3(0.0, 1.0, 0.0))),
			mPistonStartPos_stage3D(glm::rotate(glm::dvec3(0.0, mPistonStartPos_stage2D.y, -mPistonStartPos_stage2D.x), glm::radians(clockingDegree), { 0.0, 1.0, 0.0 })),
			mPusherStartPos_stage3D(mPistonStartPos_stage3D - glm::dvec3(0.0, 0.3, 0.0)),
			mAboutOrigin(InertiaTensor::parallelAxis(mCoMInertia_comp, mMass_comp.getValue(), -mMass_comp.getCentre()))
		{
			//Setup coordinate space
			mCompToStage.setLocalToParent_translation(glm::rotate(glm::dvec3(0.0, mPos_stage2D.y, -mPos_stage2D.x), glm::radians(clockingDegree), { 0.0, 1.0, 0.0 }));
			updateCompToStage_rotation();

			double minPistonLength = length(mCompToStage.toParentSpace({ 0.0, mPistonEndPos_leg2D.y, -mPistonEndPos_leg2D.x }) - mPistonStartPos_stage3D);
			mPiston = std::make_unique<TelescopingPiston>(mPistonStartPos_stage3D, clockingDegree, minPistonLength);

			double minPusherLength = length(mCompToStage.toParentSpace({ 0.0, mPusherEndPos_leg2D.y, -mPusherEndPos_leg2D.x }) - mPusherStartPos_stage3D);
			mPusher = std::make_unique<LegDeploymentActuator>(minPusherLength);
		}

		void LandingLeg::update(const CoordTransform3D& stageToWorld, glm::dvec3 legOriginAccel_world, double dt) {
			mPistonEndPos_stage3D = mCompToStage.toParentSpace({ 0.0, mPistonEndPos_leg2D.y, -mPistonEndPos_leg2D.x });
			mAlongPiston_stage3D = mPistonEndPos_stage3D - mPistonStartPos_stage3D;
			mPiston->update(glm::length(mAlongPiston_stage3D), dt);

			mPusherEndPos_stage3D = mCompToStage.toParentSpace({ 0.0, mPusherEndPos_leg2D.y, -mPusherEndPos_leg2D.x });
			mAlongPusher_stage3D = mPusherEndPos_stage3D - mPusherStartPos_stage3D;
			mPusher->update(glm::length(mAlongPusher_stage3D));

			updateState(stageToWorld, legOriginAccel_world, dt);
		}
 
		void LandingLeg::deploy() {
			if (mDeploymentPhase == Phase::stowed)
				mDeploymentPhase = Phase::deploying;
		}

		void LandingLeg::stow_temp() {
			mDeploymentPhase = Phase::stowed;
			mDeploymentAngle_rads = 0.0;
			mDeploymentVelocity_rads = 0.0;

			updateCompToStage_rotation();
		}

		void LandingLeg::updateState(const CoordTransform3D& stageToWorld, glm::dvec3 legOriginAccel_world, double dt) {
			using namespace glm;
			
			switch (mDeploymentPhase) {
			case Phase::stowed: {
				mDeploymentAngle_rads = 0.0;
				mDeploymentVelocity_rads = 0.0;
				break;
			}
			
			case Phase::deploying: {
				//1. Get the acceleration of the leg's centre of mass in world space
				dvec3 accelerationCoM_world = { 0.0, -External::Environment::seaLevelGravity, 0.0 };
			
				//2. Get the resultant acceleration in world space
				dvec3 resultantAccel_world = accelerationCoM_world - legOriginAccel_world;
			
				//3. Convert the resultant acceleration into leg space.
				dvec3 resultAccel_leg = mCompToStage.toLocalSpace_rotation(stageToWorld.toLocalSpace_rotation(resultantAccel_world));
			
				//4. Calculate a force generated by the acceleration of this point
				double mass = mMass_comp.getValue();
				dvec3
					weight_leg = resultAccel_leg * mass,
					pusherForce_leg = mCompToStage.toLocalSpace_rotation(normalize(mAlongPusher_stage3D) * mPusher->getForceMagnitude()),
					pistonForce_leg = mCompToStage.toLocalSpace_rotation(normalize(mAlongPiston_stage3D) * mPiston->getForceMagnitude());
			
				//5. Calculate a total torque generated by the forces above
				dvec3 totalTorque_leg =
					cross(mMass_comp.getCentre(), weight_leg) +
					cross(mCompToStage.toLocalSpace(mPusherEndPos_stage3D), pusherForce_leg) + 
					cross(mCompToStage.toLocalSpace(mPistonEndPos_stage3D), pistonForce_leg);
			
				//6. Calculate angular acceleration vector about the origin given torque and inertia
				dvec3 angularAccelOfOrigin = mAboutOrigin.inverse().getInternal() * totalTorque_leg;
				
				//7. Extract the angular acceleration component about the leg's rotation axis and integrate for angular velocity and then position
				mDeploymentVelocity_rads += -angularAccelOfOrigin.x * dt;
				mDeploymentAngle_rads += mDeploymentVelocity_rads * dt;
			
				clampRotationRange(mPiston->isFullyExtended() ? mDeploymentAngle_rads - mDeploymentVelocity_rads * dt : mDeploymentAngle_rads + 1.0);

				if (mDeploymentPhase == Phase::deploying && mPiston->isFullyExtended() && abs(mDeploymentVelocity_rads) < 0.05)
					mDeploymentPhase = Phase::locked;

				break;
			}
			
			case Phase::locked:
				mDeploymentVelocity_rads = 0.0;
				break;
			
			default:
				break;
			}
			
			updateCompToStage_rotation();
		}

		Mass LandingLeg::recalcMass() const {
			return Mass(600.0, { 0.0, mCentreMassPos_leg2D.y, -mCentreMassPos_leg2D.x });
		}
		
		InertiaTensor LandingLeg::recalcInertia() const {
			return InertiaTensor::solidCylinder(600.0, 0.8064, 6.943);
		}

		void LandingLeg::updateCompToStage_rotation() {
			glm::dmat4 deploymentRotation = glm::rotate(mDeploymentAngle_rads, glm::dvec3(-1.0, 0.0, 0.0));
			mCompToStage.setLocalToParent_rotation(mClockingRotation_stage * deploymentRotation);
		}

		void LandingLeg::clampRotationRange(double maxAngle) {
			if (mDeploymentAngle_rads < 0.0) {
				mDeploymentAngle_rads = 0.0;
				mDeploymentVelocity_rads = 0.0;
			}
			else if (mDeploymentAngle_rads >= maxAngle) {
				mDeploymentAngle_rads = maxAngle;
				mDeploymentVelocity_rads *= -mRestitutionCoeff;
			}
		}

	}
}