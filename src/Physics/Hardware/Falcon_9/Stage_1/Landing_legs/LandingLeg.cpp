#include "LandingLeg.h"	 

namespace Physics {
	namespace Hardware {

		LandingLeg::LandingLeg(double clockingDegree_degs) :
			IStageComponent(GF::CoordTransform3D(), 600.0),
			mPistonStartPos_stage3D(glm::rotate(glm::dvec3(0.0, mPistonStartPos_stage2D.y, -mPistonStartPos_stage2D.x), glm::radians(clockingDegree_degs), { 0.0, 1.0, 0.0 })),
			mPusherStartPos_stage3D(mPistonStartPos_stage3D - glm::dvec3(0.0, 0.3, 0.0)),
			mClockingDegree_degs(clockingDegree_degs)
		{
			using namespace glm;

			//Set up coordinate space
			mCompToStage.setLocalToParent_position(rotate(dvec3(0.0, mPos_stage2D.y, -mPos_stage2D.x), radians(clockingDegree_degs), { 0.0, 1.0, 0.0 }));
			updateCompToStage_rotation();

			//Set up inertial state
			mMass_comp.setCentre(dvec3(0.0, mCentreMassPos_leg2D.y, -mCentreMassPos_leg2D.x));
			mCMInertia_comp = InertiaTensor::solidCylinder(mMass_comp.getValue(), 0.8064, 6.943);

			double minPistonLength = length(mCompToStage.toParentSpace({ 0.0, mPistonEndPos_leg2D.y, -mPistonEndPos_leg2D.x }) - mPistonStartPos_stage3D);
			mPiston = std::make_unique<TelescopingPiston>(mPistonStartPos_stage3D, clockingDegree_degs, minPistonLength);

			double minPusherLength = length(mCompToStage.toParentSpace({ 0.0, mPusherEndPos_leg2D.y, -mPusherEndPos_leg2D.x }) - mPusherStartPos_stage3D);
			mPusher = std::make_unique<LegDeploymentActuator>(minPusherLength);
		}

		void LandingLeg::update(const GF::CoordTransform3D& stageToWorld, glm::dvec3 legOriginAccel_world, double dt) {
			mPistonEndPos_stage3D = mCompToStage.toParentSpace({ 0.0, mPistonEndPos_leg2D.y, -mPistonEndPos_leg2D.x });
			mAlongPiston_stage3D = mPistonEndPos_stage3D - mPistonStartPos_stage3D;
			mPiston->update(glm::length(mAlongPiston_stage3D), dt);

			mPusherEndPos_stage3D = mCompToStage.toParentSpace({ 0.0, mPusherEndPos_leg2D.y, -mPusherEndPos_leg2D.x });
			mAlongPusher_stage3D = mPusherEndPos_stage3D - mPusherStartPos_stage3D;
			mPusher->update(glm::length(mAlongPusher_stage3D));

			updateState(stageToWorld, legOriginAccel_world, dt);
		}

		void LandingLeg::deploy() {
			if (mDeploymentPhase == Phase::stowed)
				mDeploymentPhase = Phase::deploying;
		}

		void LandingLeg::stow_temp() {
			mDeploymentPhase = Phase::stowed;
			mDeploymentAngle_rads = 0.0;
			mDeploymentVelocity_rads = 0.0;

			updateCompToStage_rotation();
		}

		void LandingLeg::updateState(const GF::CoordTransform3D& stageToWorld, glm::dvec3 legOriginAccel_world, double dt) {
			using namespace glm;
			
			switch (mDeploymentPhase) {
			case Phase::stowed: {
				mDeploymentAngle_rads = 0.0;
				mDeploymentVelocity_rads = 0.0;
				break;
			}
			
			case Phase::deploying: {
				//1. Get the acceleration of the leg's centre of mass in world space
				dvec3 accelerationCoM_world = { 0.0, -External::Environment::seaLevelGravity, 0.0 };
			
				//2. Get the resultant acceleration in world space
				dvec3 resultantAccel_world = accelerationCoM_world - legOriginAccel_world;
			
				//3. Convert the resultant acceleration into leg space.
				dvec3 resultAccel_leg = mCompToStage.toLocalSpace_rotation(stageToWorld.toLocalSpace_rotation(resultantAccel_world));
			
				//4. Calculate a force generated by the acceleration of this point
				double mass = mMass_comp.getValue();
				dvec3
					weight_leg = resultAccel_leg * mass,
					pusherForce_leg = mCompToStage.toLocalSpace_rotation(normalize(mAlongPusher_stage3D) * mPusher->getForceMagnitude()),
					pistonForce_leg = mCompToStage.toLocalSpace_rotation(normalize(mAlongPiston_stage3D) * mPiston->getForceMagnitude());
			
				//5. Calculate a total torque generated by the forces above
				dvec3 totalTorque_leg =
					cross(mMass_comp.getCentre(), weight_leg) +
					cross(mCompToStage.toLocalSpace(mPusherEndPos_stage3D), pusherForce_leg) + 
					cross(mCompToStage.toLocalSpace(mPistonEndPos_stage3D), pistonForce_leg);
			
				//6. Prepare an inertia tensor of the leg about its origin (rather than centre of mass) using parallel axis theorem.
				InertiaTensor aboutOrigin = InertiaTensor::parallelAxis(mCMInertia_comp, mass, -mMass_comp.getCentre());
			
				//7. Calculate angular acceleration vector about the origin given torque and inertia
				dvec3 angularAccelOfOrigin = aboutOrigin.inverse().getInternal() * totalTorque_leg;
				
				//8. Extract the angular acceleration component about the leg's rotation axis and integrate for angular velocity and then position
				mDeploymentVelocity_rads += -angularAccelOfOrigin.x * dt;
				mDeploymentAngle_rads += mDeploymentVelocity_rads * dt;
			
				clampRotationRange(mPiston->isFullyExtended() ? mDeploymentAngle_rads - mDeploymentVelocity_rads * dt : mDeploymentAngle_rads + 1.0);

				if (mDeploymentPhase == Phase::deploying && mPiston->isFullyExtended() && abs(mDeploymentVelocity_rads) < 0.05)
					mDeploymentPhase = Phase::locked;

				break;
			}
			
			case Phase::locked:
				mDeploymentVelocity_rads = 0.0;
				break;
			
			default:
				break;
			}
			
			updateCompToStage_rotation();
		}

		void LandingLeg::updateCompToStage_rotation() {
			glm::dmat4
				aroundStage = glm::rotate(glm::radians(mClockingDegree_degs), glm::dvec3(0.0, 1.0, 0.0)),
				downFromStowed = glm::rotate(mDeploymentAngle_rads, glm::dvec3(-1.0, 0.0, 0.0));

			mCompToStage.setLocalToParent_rotation(aroundStage * downFromStowed);
		}

		void LandingLeg::clampRotationRange(double maxAngle) {
			if (mDeploymentAngle_rads < 0.0) {
				mDeploymentAngle_rads = 0.0;
				mDeploymentVelocity_rads = 0.0;
			}
			else if (mDeploymentAngle_rads >= maxAngle) {
				mDeploymentAngle_rads = maxAngle;
				mDeploymentVelocity_rads *= -mRestitutionCoeff;
			}
		}

	}
}

//*------------------------PLAN------------------------
/* - Generally neaten up and finalise the work that has been done with the landing legs so far.
 
 * - When calculating 'accelerationCoM_world' include the angular acceleration of the leg. This will have to be calculated by storing a previous and current velocity
     of the leg's centre of mass in world space. These will in turn require calculating the velocity of the legs CoM as a point on the stage in world space (using 
	 RigidBody function) before adding the angular velocity in world space.
 */